格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。

给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。

示例 1：

```
输入: 2
输出: [0,1,3,2]
解释:
00 - 0
01 - 1
11 - 3
10 - 2

对于给定的 n，其格雷编码序列并不唯一。
例如，[0,2,3,1] 也是一个有效的格雷编码序列。

00 - 0
10 - 2
11 - 3
01 - 1
```

示例 2：

```
输入: 0
输出: [0]
解释: 我们定义格雷编码序列必须以 0 开头。
     给定编码总位数为 n 的格雷编码序列，其长度为 2^n。当 n = 0 时，长度为 20 = 1。
     因此，当 n = 0 时，其格雷编码序列为 [0]。
     

```




思路：

```
一位组合：
0
1
二位组合： 
00
01
11
10
三位组合： 
000
001
011
010
110
111
101
100
可以发现规律：n位组合上下对称，
左侧第一竖列从上往下为2的n次方/2个0和1（对半分），
为0的组合右侧是n-1位组合的内容。
以上规则可以用递归实现。
1. 为1的时候返回['0', '1']
2. 不为1的时候在上次组合的基础上，遍历组合，每一项前面加0和1成为对称的两项，最后就得到了格雷编码数组。
3. 判断为0的情况；拿取格雷数组，parseInt(item, 2) 转换2进制为10进制，返回数组即可。
```

Code： 
```
var grayCode = function(n) {
    if (n == 0) return [0];
    let result = makeGrayCodeArr(n);
    result.forEach((item, index) => {
        result[index] = parseInt(item, 2);
    });
    return result;
};

function makeGrayCodeArr (n) {
    if (n == 1) {
        return ['0', '1'];
    } else {
        let prev = makeGrayCodeArr(n-1);
        let result = [];
        let max = Math.pow(2, n) -1;
        for (let i=0; i< prev.length; i++) {
            // 上部分
            result[i] = `0${prev[i]}`;
            // 对称部分
            result[max-i] = `1${prev[i]}`
        }
        return result;
    }
}

```